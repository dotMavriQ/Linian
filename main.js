/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinianPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/constants.ts
var DEFAULT_SETTINGS = {
  apiKey: "",
  organizationId: "",
  defaultTeam: "",
  enablePriorityIcons: true,
  enableAssigneeAvatars: true,
  cacheTimeout: 3e5,
  // 5 minutes
  maxCacheSize: 1e3
};
var SHORTCODE_PATTERN = "\\[(L_)?([A-Za-z]+(?:-[A-Za-z]*)?-\\d+)\\]";
var LINEAR_SHORTCODE_REGEX = new RegExp(SHORTCODE_PATTERN, "gi");
var createShortcodeRegex = () => new RegExp(SHORTCODE_PATTERN, "gi");
var GRAPHQL_QUERIES = {
  ISSUE_BY_IDENTIFIER: `
		query FindIssue($teamKey: String!, $number: Float!) {
			issues(filter: { 
				team: { key: { eq: $teamKey } }, 
				number: { eq: $number } 
			}) {
				nodes {
					id
					identifier
					title
					description
					url
					priority
					state {
						id
						name
						color
					}
					assignee {
						id
						name
						avatarUrl
					}
					team {
						id
						key
						name
					}
					createdAt
					updatedAt
				}
			}
		}
	`,
  ORGANIZATION_TEAMS: `
		query Teams {
			teams {
				nodes {
					id
					name
					key
				}
			}
		}
	`
};
var PRIORITY_ICONS = {
  0: "\u26AA",
  // No priority
  1: "\u{1F535}",
  // Low
  2: "\u{1F7E1}",
  // Medium
  3: "\u{1F7E0}",
  // High
  4: "\u{1F534}"
  // Urgent
};

// src/api.ts
var SimpleGraphQLClient = class {
  constructor(endpoint, headers) {
    this.endpoint = endpoint;
    this.headers = headers;
  }
  async request(query, variables = {}) {
    console.log("Making GraphQL request to Linear API");
    const response = await fetch(this.endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...this.headers
      },
      body: JSON.stringify({
        query,
        variables
      })
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    if (data.errors) {
      throw new Error(
        `GraphQL error: ${data.errors.map((e) => e.message).join(", ")}`
      );
    }
    return data.data;
  }
};
var LinearAPIService = class {
  constructor(apiKey, cacheTimeout = 3e5, maxCacheSize = 1e3) {
    this.cache = {};
    this.client = new SimpleGraphQLClient("https://api.linear.app/graphql", {
      Authorization: apiKey
      // Fixed: Capital 'A' and direct key usage per Linear docs
    });
    this.cacheTimeout = cacheTimeout;
    this.maxCacheSize = maxCacheSize;
  }
  updateApiKey(apiKey) {
    this.client = new SimpleGraphQLClient("https://api.linear.app/graphql", {
      Authorization: apiKey
      // Fixed: Capital 'A' and direct key usage per Linear docs
    });
  }
  async getIssue(identifier) {
    var _a, _b;
    console.log(`Getting issue: ${identifier}`);
    const cached = this.cache[identifier];
    if (cached && Date.now() - cached.timestamp < this.cacheTimeout) {
      console.log(`Returning cached issue: ${identifier}`);
      return cached.issue;
    }
    try {
      console.log(`Fetching issue from API: ${identifier}`);
      const match = identifier.match(/^([A-Za-z]+)-(\d+)$/);
      if (!match) {
        console.error(`Invalid identifier format: ${identifier}`);
        return null;
      }
      const [, teamKey, numberStr] = match;
      const number = parseInt(numberStr, 10);
      console.log(`Searching for team: ${teamKey}, number: ${number}`);
      const response = await this.client.request(GRAPHQL_QUERIES.ISSUE_BY_IDENTIFIER, { teamKey, number });
      console.log("API Response:", response);
      if (((_b = (_a = response.issues) == null ? void 0 : _a.nodes) == null ? void 0 : _b.length) > 0) {
        const issue = response.issues.nodes[0];
        this.updateCache(identifier, issue);
        return issue;
      }
      console.log(`No issue found for ${identifier}`);
      return null;
    } catch (error) {
      console.error("Error fetching Linear issue:", error);
      return null;
    }
  }
  async getTeams() {
    try {
      const response = await this.client.request(GRAPHQL_QUERIES.ORGANIZATION_TEAMS);
      return response.teams.nodes;
    } catch (error) {
      console.error("Error fetching Linear teams:", error);
      return [];
    }
  }
  updateCache(identifier, issue) {
    if (Object.keys(this.cache).length >= this.maxCacheSize) {
      const oldestKey = Object.keys(this.cache).sort(
        (a, b) => this.cache[a].timestamp - this.cache[b].timestamp
      )[0];
      delete this.cache[oldestKey];
    }
    this.cache[identifier] = {
      issue,
      timestamp: Date.now()
    };
  }
  clearCache() {
    this.cache = {};
  }
  getCacheStats() {
    return {
      size: Object.keys(this.cache).length,
      maxSize: this.maxCacheSize
    };
  }
};

// src/renderer.ts
var LinearRenderer = class {
  constructor(settings) {
    this.settings = settings;
  }
  createIssueElement(issue, displayMode = "compact") {
    var _a;
    const issueEl = document.createElement("a");
    issueEl.className = "linian-issue-link";
    if (displayMode === "expanded") {
      issueEl.classList.add("linian-issue-link--expanded");
    }
    issueEl.href = issue.url;
    issueEl.setAttribute(
      "aria-label",
      `Linear issue: ${issue.identifier} - ${issue.title}`
    );
    const contentEl = document.createElement("span");
    contentEl.className = "linian-issue-content";
    const shouldShowPriorityIcon = this.settings.enablePriorityIcons && issue.priority !== void 0;
    if (shouldShowPriorityIcon && displayMode === "compact") {
      const priorityEl = document.createElement("span");
      priorityEl.className = "linian-priority-icon";
      priorityEl.textContent = PRIORITY_ICONS[issue.priority] || PRIORITY_ICONS[0];
      const priorityLabels = {
        0: "No priority",
        1: "Low",
        2: "Medium",
        3: "High",
        4: "Urgent"
      };
      priorityEl.setAttribute(
        "title",
        priorityLabels[issue.priority] || "No priority"
      );
      contentEl.appendChild(priorityEl);
    }
    if (displayMode === "expanded") {
      const leadingDot = document.createElement("span");
      leadingDot.className = "linian-expanded-dot linian-expanded-dot--leading";
      leadingDot.textContent = "\u25CF";
      leadingDot.style.color = issue.state.color;
      contentEl.appendChild(leadingDot);
      const titleEl = document.createElement("span");
      titleEl.className = "linian-issue-title";
      titleEl.textContent = issue.title;
      contentEl.appendChild(titleEl);
      const trailingDot = document.createElement("span");
      trailingDot.className = "linian-expanded-dot linian-expanded-dot--trailing";
      trailingDot.textContent = "\u2022";
      trailingDot.style.color = issue.state.color;
      contentEl.appendChild(trailingDot);
    } else {
      const identifierEl = document.createElement("span");
      identifierEl.className = "linian-issue-identifier";
      identifierEl.textContent = issue.identifier;
      contentEl.appendChild(identifierEl);
      const statusEl = document.createElement("span");
      statusEl.className = "linian-status-indicator";
      statusEl.style.backgroundColor = issue.state.color;
      statusEl.setAttribute("title", issue.state.name);
      contentEl.appendChild(statusEl);
    }
    issueEl.appendChild(contentEl);
    if (displayMode === "compact" && this.settings.enableAssigneeAvatars && ((_a = issue.assignee) == null ? void 0 : _a.avatarUrl)) {
      const avatarEl = document.createElement("img");
      avatarEl.className = "linian-assignee-avatar";
      avatarEl.src = issue.assignee.avatarUrl;
      avatarEl.alt = issue.assignee.name;
      avatarEl.setAttribute("title", `Assigned to ${issue.assignee.name}`);
      issueEl.appendChild(avatarEl);
    }
    if (displayMode === "expanded") {
      this.attachTooltip(issueEl, issue);
    }
    return issueEl;
  }
  createLoadingElement(identifier, displayMode = "compact") {
    const loadingEl = document.createElement("span");
    loadingEl.className = "linian-loading";
    if (displayMode === "expanded") {
      loadingEl.classList.add("linian-loading--expanded");
      loadingEl.textContent = "Loading issue...";
    } else {
      loadingEl.textContent = identifier;
    }
    loadingEl.setAttribute("title", "Loading Linear issue...");
    return loadingEl;
  }
  createErrorElement(identifier, displayMode = "compact") {
    const errorEl = document.createElement("span");
    errorEl.className = "linian-error";
    if (displayMode === "expanded") {
      errorEl.classList.add("linian-error--expanded");
      errorEl.textContent = "Failed to load issue";
    } else {
      errorEl.textContent = identifier;
    }
    errorEl.setAttribute("title", "Failed to load Linear issue");
    return errorEl;
  }
  attachTooltip(element, issue) {
    let tooltipEl = null;
    const showTooltip = () => {
      if (tooltipEl)
        return;
      tooltipEl = document.createElement("div");
      tooltipEl.className = "linian-tooltip";
      const titleEl = document.createElement("div");
      titleEl.className = "linian-tooltip-title";
      titleEl.textContent = issue.title;
      tooltipEl.appendChild(titleEl);
      const metaEl = document.createElement("div");
      metaEl.className = "linian-tooltip-meta";
      metaEl.innerHTML = `
        <span class="linian-tooltip-status" style="background-color: ${issue.state.color}">
          ${issue.state.name}
        </span>
        <span class="linian-tooltip-team">${issue.team.name}</span>
        ${issue.assignee ? `<span class="linian-tooltip-assignee">@${issue.assignee.name}</span>` : ""}
      `;
      tooltipEl.appendChild(metaEl);
      const idEl = document.createElement("div");
      idEl.className = "linian-tooltip-identifier";
      idEl.textContent = issue.identifier;
      tooltipEl.appendChild(idEl);
      if (issue.description) {
        const descEl = document.createElement("div");
        descEl.className = "linian-tooltip-description";
        const trimmed = issue.description.replace(/\s+/g, " ");
        const preview = trimmed.slice(0, 260);
        descEl.textContent = preview + (trimmed.length > preview.length ? "\u2026" : "");
        tooltipEl.appendChild(descEl);
      }
      const rect = element.getBoundingClientRect();
      tooltipEl.style.position = "fixed";
      tooltipEl.style.top = `${rect.bottom + 8}px`;
      tooltipEl.style.left = `${rect.left}px`;
      tooltipEl.style.maxWidth = "360px";
      tooltipEl.style.zIndex = "1000";
      document.body.appendChild(tooltipEl);
    };
    const hideTooltip = () => {
      if (tooltipEl) {
        tooltipEl.remove();
        tooltipEl = null;
      }
    };
    element.addEventListener("mouseenter", showTooltip);
    element.addEventListener("mouseleave", hideTooltip);
    element.addEventListener("click", hideTooltip);
  }
  updateSettings(settings) {
    this.settings = settings;
  }
};

// src/settings.ts
var import_obsidian = require("obsidian");
var LinianSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.apiService = null;
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Linian Settings" });
    new import_obsidian.Setting(containerEl).setName("Linear API Key").setDesc(
      "Your Linear API key. You can generate one in Linear Settings > API."
    ).addText(
      (text) => text.setPlaceholder("lin_api_...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
        if (value) {
          this.apiService = new LinearAPIService(
            value,
            this.plugin.settings.cacheTimeout,
            this.plugin.settings.maxCacheSize
          );
          this.plugin.updateAPIService(this.apiService);
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Test Connection").setDesc("Test your Linear API connection").addButton(
      (button) => button.setButtonText("Test").setDisabled(!this.plugin.settings.apiKey).onClick(async () => {
        if (!this.apiService && this.plugin.settings.apiKey) {
          this.apiService = new LinearAPIService(
            this.plugin.settings.apiKey
          );
        }
        if (this.apiService) {
          button.setButtonText("Testing...");
          button.setDisabled(true);
          try {
            const teams = await this.apiService.getTeams();
            if (teams.length > 0) {
              button.setButtonText("\u2713 Connected");
              button.setCta();
            } else {
              button.setButtonText("\u2717 Failed");
              button.removeCta();
            }
          } catch (error) {
            button.setButtonText("\u2717 Error");
            button.removeCta();
          }
          setTimeout(() => {
            button.setButtonText("Test");
            button.setDisabled(false);
            button.removeCta();
          }, 3e3);
        }
      })
    );
    containerEl.createEl("h3", { text: "Display Options" });
    new import_obsidian.Setting(containerEl).setName("Show Priority Icons").setDesc("Display priority icons next to issue identifiers").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enablePriorityIcons).onChange(async (value) => {
        this.plugin.settings.enablePriorityIcons = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian.Setting(containerEl).setName("Show Assignee Avatars").setDesc("Display assignee avatars for issues").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableAssigneeAvatars).onChange(async (value) => {
        this.plugin.settings.enableAssigneeAvatars = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Performance" });
    new import_obsidian.Setting(containerEl).setName("Cache Timeout").setDesc("How long to cache issue data (in minutes)").addSlider(
      (slider) => slider.setLimits(1, 60, 1).setValue(this.plugin.settings.cacheTimeout / 6e4).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.cacheTimeout = value * 6e4;
        await this.plugin.saveSettings();
        if (this.apiService) {
          this.apiService = new LinearAPIService(
            this.plugin.settings.apiKey,
            this.plugin.settings.cacheTimeout,
            this.plugin.settings.maxCacheSize
          );
          this.plugin.updateAPIService(this.apiService);
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Max Cache Size").setDesc("Maximum number of issues to cache").addSlider(
      (slider) => slider.setLimits(100, 5e3, 100).setValue(this.plugin.settings.maxCacheSize).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxCacheSize = value;
        await this.plugin.saveSettings();
        if (this.apiService) {
          this.apiService = new LinearAPIService(
            this.plugin.settings.apiKey,
            this.plugin.settings.cacheTimeout,
            this.plugin.settings.maxCacheSize
          );
          this.plugin.updateAPIService(this.apiService);
        }
      })
    );
    new import_obsidian.Setting(containerEl).setName("Clear Cache").setDesc("Clear all cached issue data").addButton(
      (button) => button.setButtonText("Clear Cache").setWarning().onClick(() => {
        if (this.apiService) {
          this.apiService.clearCache();
          button.setButtonText("\u2713 Cleared");
          setTimeout(() => {
            button.setButtonText("Clear Cache");
          }, 2e3);
        }
      })
    );
    if (this.apiService) {
      const stats = this.apiService.getCacheStats();
      containerEl.createEl("p", {
        text: `Cache: ${stats.size}/${stats.maxSize} items`,
        cls: "setting-item-description"
      });
    }
  }
};

// src/live-preview.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_obsidian2 = require("obsidian");
var isEditorInLivePreviewMode = (view) => view.state.field(import_obsidian2.editorLivePreviewField);
var isCursorInsideTag = (view, start, length) => {
  const cursor = view.state.selection.main.head;
  return cursor > start - 1 && cursor < start + length + 1;
};
var isSelectionContainsTag = (view, start, length) => {
  const selectionBegin = view.state.selection.main.from;
  const selectionEnd = view.state.selection.main.to;
  return selectionEnd > start - 1 && selectionBegin < start + length + 1;
};
var LinearIssueWidget = class extends import_view.WidgetType {
  constructor(key, apiService, renderer, displayMode) {
    super();
    this._destroyed = false;
    this._issueKey = key;
    this._apiService = apiService;
    this._renderer = renderer;
    this._displayMode = displayMode;
    this._htmlContainer = document.createElement("span");
    this._htmlContainer.className = "linian-inline-issue linian-container";
    this.buildTag();
  }
  buildTag() {
    if (this._destroyed)
      return;
    const loadingElement = this._renderer.createLoadingElement(
      this._issueKey,
      this._displayMode
    );
    this._htmlContainer.replaceChildren(loadingElement);
    const timeoutPromise = new Promise(
      (_, reject) => setTimeout(() => reject(new Error("API timeout")), 1e4)
    );
    Promise.race([this._apiService.getIssue(this._issueKey), timeoutPromise]).then((result) => {
      if (this._destroyed)
        return;
      const issue = result;
      if (issue) {
        const issueElement = this._renderer.createIssueElement(
          issue,
          this._displayMode
        );
        this._htmlContainer.replaceChildren(issueElement);
      } else {
        const errorElement = this._renderer.createErrorElement(
          this._issueKey,
          this._displayMode
        );
        this._htmlContainer.replaceChildren(errorElement);
      }
    }).catch((error) => {
      if (this._destroyed)
        return;
      console.error("Error fetching Linear issue:", error);
      const errorElement = this._renderer.createErrorElement(
        this._issueKey,
        this._displayMode
      );
      this._htmlContainer.replaceChildren(errorElement);
    });
  }
  toDOM(view) {
    return this._htmlContainer;
  }
  destroy() {
    this._destroyed = true;
    this._htmlContainer.replaceChildren();
  }
};
var linearMatchDecorator = { ref: null };
function buildMatchDecorator(apiService, renderer) {
  linearMatchDecorator.ref = new import_view.MatchDecorator({
    regexp: LINEAR_SHORTCODE_REGEX,
    decoration: (match, view, pos) => {
      const displayMode = match[1] ? "expanded" : "compact";
      const key = match[2];
      const tagLength = match[0].length;
      if (!isEditorInLivePreviewMode(view) || isCursorInsideTag(view, pos, tagLength) || isSelectionContainsTag(view, pos, tagLength)) {
        return import_view.Decoration.mark({
          tagName: "span",
          class: "linian-shortcode-highlight"
        });
      } else {
        return import_view.Decoration.replace({
          widget: new LinearIssueWidget(
            key,
            apiService,
            renderer,
            displayMode
          )
        });
      }
    }
  });
}
function buildViewPluginClass(matchDecorator) {
  class ViewPluginClass {
    constructor(view) {
      this.decorators = matchDecorator.ref ? matchDecorator.ref.createDeco(view) : import_state.RangeSet.empty;
    }
    update(update) {
      const editorModeChanged = update.startState.field(
        import_obsidian2.editorLivePreviewField
      ) !== update.state.field(
        import_obsidian2.editorLivePreviewField
      );
      if (update.docChanged || update.startState.selection.main !== update.state.selection.main || editorModeChanged) {
        this.decorators = matchDecorator.ref ? matchDecorator.ref.createDeco(update.view) : import_state.RangeSet.empty;
      }
    }
    destroy() {
      this.decorators = import_state.RangeSet.empty;
    }
  }
  const ViewPluginSpec = {
    decorations: (viewPlugin) => viewPlugin.decorators
  };
  return {
    class: ViewPluginClass,
    spec: ViewPluginSpec
  };
}
var LinearViewPluginManager = class {
  constructor() {
    this._apiService = null;
    this._renderer = null;
    this.update();
  }
  setServices(apiService, renderer) {
    this._apiService = apiService;
    this._renderer = renderer;
    this.update();
  }
  update() {
    if (this._apiService && this._renderer) {
      buildMatchDecorator(this._apiService, this._renderer);
      const viewPluginClass = buildViewPluginClass(linearMatchDecorator);
      this._viewPlugin = import_view.ViewPlugin.fromClass(
        viewPluginClass.class,
        viewPluginClass.spec
      );
    }
  }
  getViewPlugin() {
    return this._viewPlugin || null;
  }
};

// main.ts
var LinianPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.apiService = null;
    this.renderer = null;
  }
  async onload() {
    console.log("Loading Linian plugin...");
    await this.loadSettings();
    console.log("Loaded settings:", this.settings);
    if (this.settings.apiKey) {
      console.log("API key found, initializing services");
      this.initializeServices();
    } else {
      console.log("No API key found in settings");
    }
    this.addSettingTab(new LinianSettingTab(this.app, this));
    console.log("Registering markdown post processor");
    this.postProcessor = this.registerMarkdownPostProcessor(
      this.processLinearShortcodes.bind(this)
    );
    console.log("Registering live preview editor extension");
    this.viewPluginManager = new LinearViewPluginManager();
    if (this.apiService && this.renderer) {
      this.viewPluginManager.setServices(this.apiService, this.renderer);
      const viewPlugin = this.viewPluginManager.getViewPlugin();
      if (viewPlugin) {
        this.registerEditorExtension(viewPlugin);
      }
    }
    this.addCommand({
      id: "refresh-linear-cache",
      name: "Refresh Linear Cache",
      callback: () => {
        if (this.apiService) {
          this.apiService.clearCache();
          this.app.workspace.updateOptions();
        }
      }
    });
    this.addCommand({
      id: "debug-linear-shortcodes",
      name: "Debug Linear Shortcodes",
      callback: () => {
        console.log("=== DEBUGGING LINEAR SHORTCODES ===");
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
        if (activeView) {
          const content = activeView.editor.getValue();
          console.log("Full page content:", content);
          const matches = content.match(createShortcodeRegex());
          console.log("Found matches in content:", matches);
        }
        const elements = document.querySelectorAll("*");
        let foundElements = [];
        elements.forEach((el) => {
          if (el.textContent && createShortcodeRegex().test(el.textContent)) {
            foundElements.push({
              element: el,
              tagName: el.tagName,
              className: el.className,
              innerHTML: el.innerHTML,
              textContent: el.textContent
            });
          }
        });
        console.log("Elements containing shortcodes:", foundElements);
        const currentLeaf = this.app.workspace.activeLeaf;
        if (currentLeaf && currentLeaf.view instanceof import_obsidian3.MarkdownView) {
          const markdownView = currentLeaf.view;
          console.log(
            "Manually triggering processing on:",
            markdownView.contentEl
          );
          const mockContext = {
            docId: "debug",
            sourcePath: "debug",
            frontmatter: {},
            addChild: () => {
            },
            getSectionInfo: () => null
          };
          this.processLinearShortcodes(markdownView.contentEl, mockContext);
        }
      }
    });
    console.log("Linian plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Linian plugin...");
    if (this.apiService) {
      this.apiService.clearCache();
      this.apiService = null;
    }
    if (this.renderer) {
      this.renderer = null;
    }
    if (this.viewPluginManager) {
      this.viewPluginManager = null;
    }
    const linianElements = document.querySelectorAll(
      ".linian-inline-issue"
    );
    linianElements.forEach((el) => el.remove());
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    if (this.renderer) {
      this.renderer.updateSettings(this.settings);
    }
  }
  updateAPIService(apiService) {
    this.apiService = apiService;
    this.initializeRenderer();
  }
  initializeServices() {
    this.apiService = new LinearAPIService(
      this.settings.apiKey,
      this.settings.cacheTimeout,
      this.settings.maxCacheSize
    );
    this.initializeRenderer();
  }
  initializeRenderer() {
    if (!this.apiService)
      return;
    this.renderer = new LinearRenderer(this.settings);
    if (this.viewPluginManager) {
      this.viewPluginManager.setServices(this.apiService, this.renderer);
      const viewPlugin = this.viewPluginManager.getViewPlugin();
      if (viewPlugin) {
        this.registerEditorExtension(viewPlugin);
      }
    }
  }
  async processLinearShortcodes(element, context) {
    console.log("processLinearShortcodes called with element:", element);
    console.log("Element innerHTML:", element.innerHTML);
    console.log("API Service:", !!this.apiService);
    console.log("Renderer:", !!this.renderer);
    console.log("Settings API Key:", !!this.settings.apiKey);
    if (!this.apiService && this.settings.apiKey) {
      console.log("Initializing services in post processor");
      this.initializeServices();
    }
    if (!this.apiService || !this.renderer) {
      console.log("Services not initialized, skipping processing");
      return;
    }
    console.log("Processing Linear shortcodes in element:", element);
    await this.convertInlineIssuesToTags(element);
  }
  async convertInlineIssuesToTags(el) {
    var _a, _b;
    if (!this.apiService || !this.renderer) {
      console.log("convertInlineIssuesToTags: Services not available");
      return;
    }
    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
    const textNodes = [];
    while (walker.nextNode()) {
      const current = walker.currentNode;
      if (!((_a = current.nodeValue) == null ? void 0 : _a.length))
        continue;
      if ((_b = current.parentElement) == null ? void 0 : _b.closest(".linian-inline-issue"))
        continue;
      textNodes.push(current);
    }
    if (!textNodes.length) {
      console.log("No text nodes to process");
    }
    textNodes.forEach((textNode) => {
      var _a2, _b2;
      const sourceText = (_a2 = textNode.nodeValue) != null ? _a2 : "";
      const regex = createShortcodeRegex();
      let match;
      let lastIndex = 0;
      let hasMatch = false;
      const fragment = document.createDocumentFragment();
      while ((match = regex.exec(sourceText)) !== null) {
        hasMatch = true;
        const precedingText = sourceText.slice(lastIndex, match.index);
        if (precedingText) {
          fragment.appendChild(document.createTextNode(precedingText));
        }
        const displayMode = match[1] ? "expanded" : "compact";
        const identifier = match[2];
        const container = document.createElement("span");
        container.className = "linian-inline-issue linian-container";
        container.setAttribute("data-issue-key", identifier);
        container.setAttribute("data-display-mode", displayMode);
        const loadingElement = this.renderer.createLoadingElement(
          identifier,
          displayMode
        );
        container.appendChild(loadingElement);
        fragment.appendChild(container);
        lastIndex = regex.lastIndex;
      }
      if (!hasMatch) {
        return;
      }
      const trailingText = sourceText.slice(lastIndex);
      if (trailingText) {
        fragment.appendChild(document.createTextNode(trailingText));
      }
      (_b2 = textNode.parentNode) == null ? void 0 : _b2.replaceChild(fragment, textNode);
    });
    const inlineIssueTags = el.querySelectorAll(
      "span.linian-inline-issue:not([data-rendered])"
    );
    console.log("Found inline issue tags:", inlineIssueTags.length);
    for (const container of Array.from(inlineIssueTags)) {
      const issueKey = container.getAttribute("data-issue-key");
      const displayMode = container.getAttribute("data-display-mode") || "compact";
      if (issueKey) {
        console.log(
          `Fetching issue: ${issueKey} (displayMode: ${displayMode})`
        );
        this.fetchAndRenderIssue(issueKey, container, displayMode);
      }
    }
  }
  async fetchAndRenderIssue(identifier, containerElement, displayMode) {
    if (!this.apiService || !this.renderer)
      return;
    try {
      console.log(`Fetching Linear issue: ${identifier}`);
      const issue = await this.apiService.getIssue(identifier);
      console.log("Fetched issue:", issue);
      if (issue) {
        const issueElement = this.renderer.createIssueElement(
          issue,
          displayMode
        );
        containerElement.replaceChildren(issueElement);
        containerElement.setAttribute("data-rendered", "true");
        console.log(`Rendered issue: ${identifier}`);
      } else {
        const errorElement = this.renderer.createErrorElement(
          identifier,
          displayMode
        );
        containerElement.replaceChildren(errorElement);
        containerElement.setAttribute("data-rendered", "true");
        console.log(`Issue not found: ${identifier}`);
      }
    } catch (error) {
      console.error("Error fetching Linear issue:", error);
      const errorElement = this.renderer.createErrorElement(
        identifier,
        displayMode
      );
      containerElement.replaceChildren(errorElement);
      containerElement.setAttribute("data-rendered", "true");
    }
  }
};
